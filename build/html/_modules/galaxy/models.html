
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>galaxy.models &#8212; wilfried library 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for galaxy.models</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>

<span class="sd">Useful functions for galaxy modelling and other related computation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>                              <span class="k">as</span>     <span class="nn">np</span>
<span class="kn">from</span>   <span class="nn">astropy.modeling.functional_models</span> <span class="kn">import</span> <span class="n">Sersic2D</span>
<span class="kn">from</span>   <span class="nn">.misc</span>                              <span class="kn">import</span> <span class="n">check_bns</span><span class="p">,</span> <span class="n">compute_bn</span><span class="p">,</span> <span class="n">PSFconvolution2D</span><span class="p">,</span> <span class="n">checkAndComputeIe</span><span class="p">,</span> <span class="n">intensity_at_re</span>
<span class="kn">from</span>   <span class="nn">astropy.constants</span>                  <span class="kn">import</span> <span class="n">G</span>

<span class="c1"># If Planck18 not available we use Planck15</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">astropy.cosmology</span>                <span class="kn">import</span> <span class="n">Planck18</span> <span class="k">as</span> <span class="n">cosmo</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">astropy.cosmology</span>                <span class="kn">import</span> <span class="n">Planck15</span> <span class="k">as</span> <span class="n">cosmo</span>



<span class="c1">####################################################################################################################</span>
<span class="c1">#                                           1D profiles                                                            #</span>
<span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="bulge"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.bulge">[docs]</a><span class="k">def</span> <span class="nf">bulge</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">b4</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Computes the value of the intensity of a de Vaucouleur bulge at position r defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \Sigma(r) = I_{\rm{e}} e^{\left [ \left (r/R_{\rm{e}} \right )^{1/4} - 1 \right ]},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`R_{\rm{e}}` the effective radius and :math:`I_{\rm{e}}` the surface brightness at the effective radius.</span>

<span class="sd">    :param float r: position at which the profile is computed</span>
<span class="sd">    :param float re: half-light radius</span>
<span class="sd">                </span>
<span class="sd">    :param float b4: (**Optional**) b4 factor appearing in the Sersic profile. If None, its value will be computed.</span>
<span class="sd">    :param float Ie: (**Optional**) surface brightness at half-light radius</span>
<span class="sd">    :param float mag: (**Optional**) total integrated magnitude used to compute Ie if not given</span>
<span class="sd">    :param float offset: (**Optional**) magnitude offset in the magnitude system used</span>
<span class="sd">        </span>
<span class="sd">    :returns: surface brightness</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">b4</span><span class="p">,</span> <span class="o">=</span> <span class="n">check_bns</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">b4</span><span class="p">])</span>
    <span class="n">Ie</span>  <span class="o">=</span> <span class="n">checkAndComputeIe</span><span class="p">(</span><span class="n">Ie</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b4</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sersic_profile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="n">Ie</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">b4</span><span class="p">)</span></div>


<div class="viewcode-block" id="exponential_disk"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.exponential_disk">[docs]</a><span class="k">def</span> <span class="nf">exponential_disk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Computes the value of the intensity of an exponential disk at position r defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \Sigma(r) = I_{\rm{e}} e^{\left [ r/R_{\rm{e}} - 1 \right ]},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`R_{\rm{e}}` the effective radius and :math:`I_{\rm{e}}` the surface brightness at the effective radius.</span>
<span class="sd">    </span>
<span class="sd">    :param float r: position at which the profile is computed</span>
<span class="sd">    :param float re: half-light radius</span>
<span class="sd">                </span>
<span class="sd">    :param float b1: (**Optional**) b1 factor appearing in the Sersic profile. If None, its value will be computed.</span>
<span class="sd">    :param float Ie: (**Optional**) surface brightness at half-light radius</span>
<span class="sd">    :param float mag: (**Optional**) total integrated magnitude used to compute Ie if not given</span>
<span class="sd">    :param float offset: (**Optional**) magnitude offset in the magnitude system used</span>
<span class="sd">        </span>
<span class="sd">    :returns: surface brightness</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">b1</span><span class="p">,</span> <span class="o">=</span> <span class="n">check_bns</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">b1</span><span class="p">])</span>
    <span class="n">Ie</span>  <span class="o">=</span> <span class="n">checkAndComputeIe</span><span class="p">(</span><span class="n">Ie</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sersic_profile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="n">Ie</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">b1</span><span class="p">)</span></div>


<div class="viewcode-block" id="hernquist"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.hernquist">[docs]</a><span class="k">def</span> <span class="nf">hernquist</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Hernquist profile defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \rho(r) = \frac{M_{\rm{b}}}{2\pi} \frac{a}{r} (r + a)^{-3},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`M_{\rm{b}}` the total mass and :math:`a` the scale radius.</span>

<span class="sd">    :param a: scale radius</span>
<span class="sd">    :type a: int or float</span>
<span class="sd">    :param M: total mass</span>
<span class="sd">    :type M: int or float</span>
<span class="sd">    :param r: radial distance(s) where to compute the Hernquist profile. Unit must be the same as **a**.</span>
<span class="sd">    :type r: int or float or ndarray[int] or ndarray[float]</span>

<span class="sd">    :returns: Hernquist profile evaluated at the given distance(s). Unit is that of **M**/**a^3**.</span>
<span class="sd">    :rtype: float or ndarray[float]</span>
<span class="sd">    </span>
<span class="sd">    :raises TypeError: if **r**, **M** and **a** are neither int, nor float</span>
<span class="sd">    :raises ValueError: if np.any(**r**) &lt; 0, if **a** &lt;= 0 or if **M** &lt; 0</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Checking dtypes and values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span>   <span class="n">r</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;r must either be int or float, or a numpy array of the same types. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;M must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;a must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">a</span><span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a must be positive only. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span>   <span class="n">M</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">*</span><span class="n">r</span>
    <span class="k">elif</span> <span class="n">M</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;M must be positive only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="n">out</span>        <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="nfw"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.nfw">[docs]</a><span class="k">def</span> <span class="nf">nfw</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">rs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    NFW profile defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \rho(r) = \delta_{\rm{c}} \rho_{\rm{crit}} (r/r_{\rm{s}})^{-1} (1 + r/r_{\rm{s}})^{-2},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`r_{\rm{s}} = r_{200} / c` the halo scale radius, with :math:`r_{200}` the virial radius where the mean overdensity is equal to 200, :math:`c` the halo concentration, :math:`\rho_{\rm{crit}} = 3 H_0^2 / (8\pi G)` the Universe closure density, and :math:`\delta_{\rm{c}}` the halo overdensity.</span>

<span class="sd">    :param c: halo concentration</span>
<span class="sd">    :type c: int or float</span>
<span class="sd">    :param r: radial distance(s) where to compute the profile. Unit must be the same as rs.</span>
<span class="sd">    :type r: int or float or ndarray[int] or ndarray[float]</span>
<span class="sd">    :param rs: scale radius</span>
<span class="sd">    :type rs: int or float</span>
<span class="sd">        </span>
<span class="sd">    :returns: NFW profile evaluated at the given distance. Unit is that of a 3D mass density in SI (i.e. kg/m^3).</span>
<span class="sd">    :rtype: float or ndarray[float]</span>
<span class="sd">    </span>
<span class="sd">    :raises TypeError: if **r**, **c** and **rs** are neither int, nor float</span>
<span class="sd">    :raises ValueError: if np.any(**r**)&lt;0, if c&lt;=0, or if rs&lt;=0</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Checking dtypes and values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span>   <span class="n">r</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;r must either be int or float, or a numpy array of the same types. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;c must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;rs must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;c must be positive only. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">rs</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rs must be positive only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="n">deltaC</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">200</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="p">))</span>
    <span class="n">rhoCrit</span>    <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">cosmo</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">G</span><span class="p">)</span>
    <span class="n">out</span>        <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaC</span><span class="o">*</span><span class="n">rhoCrit</span> <span class="o">/</span> <span class="p">((</span><span class="n">r</span><span class="o">/</span><span class="n">rs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">r</span><span class="o">/</span><span class="n">rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="sersic_profile"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.sersic_profile">[docs]</a><span class="k">def</span> <span class="nf">sersic_profile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    General Sersic profile defined as </span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \Sigma(r) = I_{\rm{e}} e^{\left [ \left (r/R_{\rm{e}} \right )^{1/n} - 1 \right ]},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`R_{\rm{e}}` the effective radius, :math:`I_{\rm{e}}` the surface brightness at the effective radius and :math:`n` the Sersic index.</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        </span>
<span class="sd">        Compute it with:</span>
<span class="sd">            </span>
<span class="sd">            * n, re and Ie</span>
<span class="sd">            * n, re, mag and offset</span>
<span class="sd">            </span>
<span class="sd">    :param float r: position at which the profile is computed</span>
<span class="sd">    :param float re: half-light radius</span>
<span class="sd">                </span>
<span class="sd">    :param float bn: (**Optional**) bn factor appearing in the Sersic profile. If None, its value will be computed.</span>
<span class="sd">    :param float Ie: (**Optional**) surface brightness at half-light radius</span>
<span class="sd">    :param float mag: (**Optional**) total integrated magnitude used to compute Ie if not given</span>
<span class="sd">    :param float offset: (**Optional**) magnitude offset in the magnitude system used</span>
<span class="sd">        </span>
<span class="sd">    :returns: surface brightness</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">bn</span><span class="p">,</span> <span class="o">=</span> <span class="n">check_bns</span><span class="p">([</span><span class="n">n</span><span class="p">],</span> <span class="p">[</span><span class="n">bn</span><span class="p">])</span>
    <span class="n">Ie</span>  <span class="o">=</span> <span class="n">checkAndComputeIe</span><span class="p">(</span><span class="n">Ie</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Ie</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="n">bn</span><span class="o">*</span><span class="p">((</span><span class="n">r</span><span class="o">/</span><span class="n">re</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span></div>


<span class="c1">####################################################################################################</span>
<span class="c1">#                                      2D modelling                                                #</span>
<span class="c1">####################################################################################################</span>

<div class="viewcode-block" id="bulgeDiskOnSky"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.bulgeDiskOnSky">[docs]</a><span class="k">def</span> <span class="nf">bulgeDiskOnSky</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magD</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offsetD</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offsetB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclination</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">PA</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">PSF</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;Gaussian2D&#39;</span><span class="p">,</span> <span class="s1">&#39;FWHMX&#39;</span><span class="p">:</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;FWHMY&#39;</span><span class="p">:</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;sigmaX&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sigmaY&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span><span class="s1">&#39;arcsec&#39;</span><span class="p">},</span> <span class="n">noPSF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
                   <span class="n">fineSampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;centre&#39;</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">},</span> <span class="n">skipCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Generate a bulge + (sky projected) disk 2D model (with PSF convolution).</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        </span>
<span class="sd">        **How to use**</span>
<span class="sd">        </span>
<span class="sd">        Apart from the mandatory inputs, it is necessary to provide:</span>
<span class="sd">        </span>
<span class="sd">            * an intensity at Re for each profile</span>
<span class="sd">            * a total magnitude value for each profile and a corresponding magnitude offset per profile (to convert from magnitudes to intensities)</span>
<span class="sd">       </span>
<span class="sd">       **Infos about sampling** </span>
<span class="sd">       </span>
<span class="sd">        **fineSampling** parameter can be used to rebin the data. The shape of the final image will depend on the samplingZone used:</span>
<span class="sd">            </span>
<span class="sd">            * if the sampling is performed everywhere (&#39;where&#39; keyword in **samplingZone** equal to &#39;all&#39;), the final image will have dimensions (**nx*fineSampling**, **ny*fineSampling**)</span>
<span class="sd">            * if the sampling is performed around the centre (&#39;where&#39; equal to &#39;centre&#39;), the central part is over-sampled, but needs to be binned in the end so that pixels have the same size in the central part and around. Thus, the final image will have the dimension (**nx**, **ny**).        </span>
<span class="sd">       </span>
<span class="sd">    .. warning::</span>
<span class="sd">        </span>
<span class="sd">        **Rd** and **Rb** should be given in pixel units. </span>
<span class="sd">        If you provide them in arcsec, you must update the **arcsecToGrid** value to 1 (since 1 pixel will be equal to 1 arcsec). </span>
<span class="sd">    </span>
<span class="sd">    :param int nx: size of the model for the x-axis</span>
<span class="sd">    :param int ny: size of the model for the y-axis</span>
<span class="sd">    :param float Rb: bulge half-light radius. Best practice is to provide it in pixels.</span>
<span class="sd">    :param float Rd: disk half-light radius. Best practice is to provide it in pixels.</span>

<span class="sd">    :param float arcsecToGrid: (**Optional**) pixel size conversion in arcsec/pixel, used to convert the FWHM/sigma from arcsec to pixel      </span>
<span class="sd">    :param float Ib: (**Optional**) bulge intensity at (bulge) half-light radius. If not provided, magnitude and magnitude offset must be given instead.</span>
<span class="sd">    :param float Id: (**Optional**) disk intensity at (disk) half-light radius. If not provided, magnitude and magnitude offset must be given instead.</span>
<span class="sd">    :param inclination: (**Optional**) disk inclination on sky. Generally given between -90° and +90°. Value must be given in degrees.</span>
<span class="sd">    :type inclination: (**Optional**) int or float</span>
<span class="sd">    :param float magB: (**Optional**) bulge total magnitude</span>
<span class="sd">    :param float magD: (**Optional**) disk total magnitude</span>
<span class="sd">    :param float offsetB: (**Optional**) bulge magnitude offset</span>
<span class="sd">    :param float offsetD: (**Optional**) disk magnitude offset</span>
<span class="sd">    :param bool noPSF: (**Optional**) whether to not perform PSF convolution or not</span>
<span class="sd">    :param PA: disk position angle (in degrees)</span>
<span class="sd">    :type PA: int or float</span>
<span class="sd">    :param int(&gt;0) fineSampling: fine sampling for the pixel grid used to make high resolution models. For instance, a value of 2 means that a pixel will be split into two subpixels.</span>
<span class="sd">    :param dict PSF: (**Optional**) Dictionnary of the PSF (and its parameters) to use for the convolution. For now, only 2D Gaussians are accepted as PSF. </span>
<span class="sd">    :param dict samplingZone: where to perform the over sampling. Dictionnaries should have the following keys:</span>
<span class="sd">    </span>
<span class="sd">        * &#39;where&#39; (type str) -&gt; either &#39;all&#39; to perform everywhere or &#39;centre&#39; to perform around the centre</span>
<span class="sd">        * &#39;dx&#39;    (type int) -&gt; x-axis maximum distance from the centre coordinate. A sub-array with x-axis values within [xpos-dx, xpos+dx] will be selected. If the sampling is performed everywhere, &#39;dx&#39; does not need to be provided.</span>
<span class="sd">        * &#39;dy&#39;    (type int) -&gt; y-axis maximum distance from the centre coordinate. A sub-array with y-axis values within [ypos-dy, ypos+dy] will be selected. If the sampling is performed everywhere, &#39;dy&#39; does not need to be provided.</span>
<span class="sd">               </span>
<span class="sd">    :param bool skipCheck: whether to skip the checking part or not</span>
<span class="sd">    :param x0: x-axis centre position. Default is None so that nx//2 will be used.</span>
<span class="sd">    :type x0: int or float</span>
<span class="sd">    :param y0: y-axis centre position. Default is None so that ny//2 will be used.</span>
<span class="sd">    :type y0: int or float</span>
<span class="sd">    :param bool verbose: whether to print text on stdout or not</span>
<span class="sd">    </span>
<span class="sd">    :returns: X, Y grids and the total (sky projected + PSF convolved) model of the bulge + disk decomposition</span>
<span class="sd">    :rtype: 2D ndarray, 2D ndarray, 2D ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1">##############################################</span>
    <span class="c1">#          Checking input parameters         #</span>
    <span class="c1">##############################################</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipCheck</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;where&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sampling zone was not provided or syntax was incorrect. Thus, performing sampling (if relevant) on the full array.&#39;</span><span class="p">)</span>
            <span class="n">samplingZone</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;all&#39;</span><span class="p">}</span>
            
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;centre&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;where&#39; keyword in samplingZone dictionnary should be either &#39;all&#39; or &#39;centre&#39;. Cheers !&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;centre&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span> <span class="ow">or</span> <span class="s1">&#39;dy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;&#39;dx&#39; and &#39;dy&#39; keywords were missing in samplingZone dictionnary with &#39;where&#39; keyword equal to &#39;centre&#39;. Please provide values for the sampling box size around the centre. Cheers !&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;At least one of the following keys in samplingZone dictionnary was not given as an integer: &#39;dx&#39; or &#39;dy&#39;. Please provide these as int. Cheers !&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fineSampling</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Given fine sampling parameter does not have the following type: int. Please provide integer only fineSampling values. Cheers !&#39;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">fineSampling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Fine sampling cannot be less than 1.&#39;</span><span class="p">)</span>
         
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one of the following parameters was provided as a negative number, which is not correct: nx, ny, Rd, Rb, arcsecToGrid.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Checking PA</span>
        <span class="k">if</span> <span class="n">PA</span><span class="o">&lt;-</span><span class="mi">90</span> <span class="ow">or</span> <span class="n">PA</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;PA should be given in the range -90° &lt;= PA &lt;= 90°, counting angles anti clock-wise (0° means major axis is vetically aligned). Cheers !&#39;</span><span class="p">)</span>

    <span class="c1">##################################</span>
    <span class="c1">#         Compute models         #</span>
    <span class="c1">##################################</span>

    <span class="n">listn</span>       <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="n">listbn</span>      <span class="o">=</span> <span class="p">[</span><span class="n">compute_bn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">listn</span><span class="p">]</span>

    <span class="c1"># Checking that we have the correct information to model correctly our data    </span>
    <span class="k">if</span> <span class="n">Id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">magD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offsetD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Id</span>  <span class="o">=</span> <span class="n">intensity_at_re</span><span class="p">(</span><span class="n">listn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">magD</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">offsetD</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">listbn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Id is None, but magD or offsetD is also None. If no Id is given, please provide a value for the total magnitude and magnitude offset in order to compute the intensity. Cheers !&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">Ib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">magB</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offsetB</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Ib</span>  <span class="o">=</span> <span class="n">intensity_at_re</span><span class="p">(</span><span class="n">listn</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">magB</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">offsetB</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">listbn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ib is None, but magB or offsetB is also None. If no Ib is given, please provide a value for the total magnitude and magnitude offset in order to compute the intensity. Cheers !&quot;</span><span class="p">)</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">model2D</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="p">[</span><span class="n">Rd</span><span class="p">,</span> <span class="n">Rb</span><span class="p">],</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">listIe</span><span class="o">=</span><span class="p">[</span><span class="n">Id</span><span class="p">,</span> <span class="n">Ib</span><span class="p">],</span> <span class="n">listInclination</span><span class="o">=</span><span class="p">[</span><span class="n">inclination</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">listPA</span><span class="o">=</span><span class="p">[</span><span class="n">PA</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fineSampling</span><span class="o">=</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="n">samplingZone</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">noPSF</span><span class="p">:</span>
        <span class="c1"># If we perform fine sampling only in the central part, model2D function rebins the data in the end, so the arcsec to pixel conversion factor does not need to be updated since we do not have a finer pixel scale</span>
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;centre&#39;</span><span class="p">:</span>
            <span class="n">fineSampling</span>   <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">model</span>          <span class="o">=</span> <span class="n">PSFconvolution2D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">PSF</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="n">arcsecToGrid</span><span class="o">/</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mod</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                <span class="n">model</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">PSFconvolution2D</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">PSF</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="n">arcsecToGrid</span><span class="o">/</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span></div>


<div class="viewcode-block" id="model2D"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.model2D">[docs]</a><span class="k">def</span> <span class="nf">model2D</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listIe</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listMag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listOffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listInclination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listPA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">fineSampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;centre&#39;</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">},</span> <span class="n">skipCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Generate a (sky projected) 2D model (image) of a sum of Sersic profiles. Neither PSF smoothing, nor projections onto the sky whatsoever are applied here.</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        </span>
<span class="sd">        **How to use**</span>
<span class="sd">        </span>
<span class="sd">        Apart from the mandatory inputs, it is necessary to provide:</span>
<span class="sd">        </span>
<span class="sd">            * an intensity at Re for each profile</span>
<span class="sd">            * a total magnitude value for each profile and a corresponding magnitude offset per profile (to convert from magnitudes to intensities)</span>
<span class="sd">       </span>
<span class="sd">       **Infos about sampling** </span>
<span class="sd">  </span>
<span class="sd">        **fineSampling** parameter can be used to rebin the data. The shape of the final image will depend on the samplingZone used:</span>
<span class="sd">            </span>
<span class="sd">            * if the sampling is performed everywhere (&#39;where&#39; keyword in **samplingZone** equal to &#39;all&#39;), the final image will have dimensions (**nx*fineSampling**, **ny*fineSampling**)</span>
<span class="sd">            * if the sampling is performed around the centre (&#39;where&#39; equal to &#39;centre&#39;), the central part is over-sampled, but needs to be binned in the end so that pixels have the same size in the central part and around. Thus, the final image will have the dimension (**nx**, **ny**).        </span>
<span class="sd">       </span>
<span class="sd">    :param listn: list of Sersic index for each profile</span>
<span class="sd">    :type listn: list[int] or list[float]</span>
<span class="sd">    :param list[float] listRe: list of half-light radii for each profile</span>
<span class="sd">    :param int nx: size of the model for the x-axis</span>
<span class="sd">    :param int ny: size of the model for the y-axis</span>
<span class="sd">    </span>
<span class="sd">    :param bool combine: (**Optional**) whether to combine (sum) all the components and return a single intensity map, or to return each component separately in lists</span>
<span class="sd">    :param list[float] listIe: (**Optional**) list of intensities at re for each profile</span>
<span class="sd">    :param listInclination: (**Optional**) list of inclination of each Sersic component on the sky in degrees</span>
<span class="sd">    :type listInclination: list[int] or list[float]</span>
<span class="sd">    :type list[float] listMag: (**Optional**) list of total integrated magnitudes for each profile</span>
<span class="sd">    :type list[float] listOffset: (**Optional**) list of magnitude offsets used in the magnitude system for each profile</span>
<span class="sd">    :param listPA: (**Optional**) list of position angle of each Sersic component on the sky in degrees. Generally, these values are given between -90° and +90°.</span>
<span class="sd">    :type listPA: list[int] or list[float]</span>
<span class="sd">    :param int(&gt;0) fineSampling: (**Optional**) fine sampling for the pixel grid used to make high resolution models. For instance, a value of 2 means that a pixel will be split into two subpixels.</span>
<span class="sd">    :param dict samplingZone: (**Optional**) where to perform the sampling. Default is everywhere. Dictionnaries should have the following keys:</span>
<span class="sd">       </span>
<span class="sd">        * &#39;where&#39; (type str) -&gt; either &#39;all&#39; to perform everywhere or &#39;centre&#39; to perform around the centre</span>
<span class="sd">        * &#39;dx&#39;    (type int) -&gt; x-axis maximum distance from the centre coordinate. An sub-array with x-axis values within [xpos-dx, xpos+dx] will be selected. If the sampling is performed everywhere, &#39;dx&#39; does not need to be provided.</span>
<span class="sd">        * &#39;dy&#39;    (type int) -&gt; y-axis maximum distance from the centre coordinate. An sub-array with y-axis values within [ypos-dy, ypos+dy] will be selected. If the sampling is performed everywhere, &#39;dy&#39; does not need to be provided.</span>
<span class="sd">          </span>
<span class="sd">    :param bool skipCheck: (**Optional**) whether to skip the checking part or not</span>
<span class="sd">    :param x0: (**Optional**) x-axis centre position. Default is None so that **nx**//2 will be used.</span>
<span class="sd">    :type x0: int or float</span>
<span class="sd">    :param y0: (**Optional**) y-axis centre position. Default is None so that **ny**//2 will be used.</span>
<span class="sd">    :type y0: int or float</span>
<span class="sd">        </span>
<span class="sd">    :returns: </span>
<span class="sd">        - X, Y grids and the intensity map if **combine** is True</span>
<span class="sd">        - X, Y grids and a listof intensity maps for each component if **combine** is False</span>
<span class="sd">        </span>
<span class="sd">    :raises TypeError: if &#39;dx&#39; and &#39;dy&#39; keys not in **samplingZone**, if **fineSampling**, **nx** and **ny** are neither int, nor np.integer</span>
<span class="sd">    :raises ValueError: if &#39;where&#39; key value in **samplingZone** is neither &#39;all&#39;, nor &#39;centre&#39;, if **fineSampling** &lt; 1, if at least one PA is not in the range [-90, 90] deg, or if Ie and mag and offset are None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">computeSersic</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">):</span>
        
        <span class="c1"># We need not specify a centre coordinate offset, because the X and Y grids are automatically centred on the real centre.</span>
        <span class="c1"># If we combine models, we add them, if we do not combine them, we place them into a list</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">ie</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">pa</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nbModels</span><span class="p">),</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">):</span>
            
            <span class="c1"># We add 90 to PA because we want a PA=0° galaxy to be aligned with the vertical axis</span>
            <span class="n">ell</span>                <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">inc</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
            <span class="n">pa</span>                <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
            <span class="n">theModel</span>           <span class="o">=</span> <span class="n">Sersic2D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">ie</span><span class="p">,</span> <span class="n">r_eff</span><span class="o">=</span><span class="n">re</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">x_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ellip</span><span class="o">=</span><span class="n">ell</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">pa</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
                    <span class="n">intensity</span>  <span class="o">=</span> <span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intensity</span>  <span class="o">=</span> <span class="p">[</span><span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
                    <span class="n">intensity</span> <span class="o">+=</span> <span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intensity</span> <span class="o">+=</span> <span class="p">[</span><span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">intensity</span>
    
    <span class="c1">##############################################</span>
    <span class="c1">#          Checking input parameters         #</span>
    <span class="c1">############################################## </span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipCheck</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;where&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sampling zone was not provided or syntax was incorrect. Thus, performing sampling (if relevant) on the full array.&#39;</span><span class="p">)</span>
            <span class="n">samplingZone</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;all&#39;</span><span class="p">}</span>
            
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;centre&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;where&#39; keyword in samplingZone dictionnary should be either &#39;all&#39; or &#39;centre&#39;. Cheers !&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;centre&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span> <span class="ow">or</span> <span class="s1">&#39;dy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;&#39;dx&#39; and &#39;dy&#39; keywords were missing in samplingZone dictionnary with &#39;where&#39; keyword equal to &#39;centre&#39;. Please provide values for the sampling box size around the centre. Cheers !&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;At least one of the following keys in samplingZone dictionnary was not given as an integer: &#39;dx&#39; or &#39;dy&#39;. Please provide these as int. Cheers !&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fineSampling</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;One of the following parameter is not an integer, which is not valid: fineSampling (</span><span class="si">%s</span><span class="s1">), nx (</span><span class="si">%s</span><span class="s1">), ny (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fineSampling</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="n">fineSampling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Fine sampling cannot be less than 1.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Checking PA</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">pa</span><span class="o">&lt;-</span><span class="mi">90</span> <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="n">listPA</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="n">pa</span><span class="o">&gt;</span><span class="mi">90</span> <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="n">listPA</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;PA should be given in the range -90° &lt;= PA &lt;= +90°, counting angles anti clock-wise. Cheers !&#39;</span><span class="p">)</span>  

    <span class="k">if</span> <span class="n">listIe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">listMag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">listOffset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">listIe</span>         <span class="o">=</span> <span class="n">intensity_at_re</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listn</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listMag</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listRe</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listOffset</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;listIe is None, but listMag or listOffset is also None. If no listIe is given, please provide a value for the total magnitude and magnitude offset in order to compute the intensities. Cheers !&quot;</span><span class="p">)</span>

    <span class="n">nbModels</span>               <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">listn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">listInclination</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">listInclination</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nbModels</span>
    <span class="k">if</span> <span class="n">listPA</span>          <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">listPA</span>             <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nbModels</span>
    
    <span class="c1">##################################</span>
    <span class="c1">#         Compute models         #</span>
    <span class="c1">##################################</span>

    <span class="c1"># Define image centre</span>
    <span class="n">midX</span>                   <span class="o">=</span> <span class="n">nx</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">midY</span>                   <span class="o">=</span> <span class="n">ny</span><span class="o">//</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x0</span>                 <span class="o">=</span> <span class="n">midX</span>
    <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y0</span>                 <span class="o">=</span> <span class="n">midY</span>
        
    <span class="c1"># Pixel width is not 1 if we use fineSampling</span>
    <span class="n">pixWidth</span>               <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fineSampling</span>
    <span class="n">pixHeight</span>              <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fineSampling</span>
    
    <span class="c1"># We centre the coordinate X and Y grids to the given centre coordinates</span>
    <span class="c1"># The centre is recentred inside an &#39;original&#39; pixel because of fine sampling (to not break any symmetry when rebinning)</span>
    <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">newX0</span>              <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pixWidth</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">newY0</span>              <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pixHeight</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">listX</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">pixWidth</span><span class="p">)</span>  <span class="o">-</span> <span class="n">newX0</span>
        <span class="n">listY</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixHeight</span><span class="p">)</span> <span class="o">-</span> <span class="n">newY0</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">listX</span><span class="p">,</span> <span class="n">listY</span><span class="p">)</span>
        <span class="n">intensity</span>          <span class="o">=</span> <span class="n">computeSersic</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">fineSampling</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Rebinning intensity map in the central part</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        intensity   = intensity.reshape(int(intensity.shape[0] / fineSampling), fineSampling, int(intensity.shape[1] / fineSampling), fineSampling)</span>
<span class="sd">        intensity   = intensity.mean(1).mean(2)</span>
<span class="sd">        </span>
<span class="sd">        listX              = np.arange(0, nx, 1) - x0</span>
<span class="sd">        listY              = np.arange(0, ny, 1) - y0</span>
<span class="sd">        X, Y               = np.meshgrid(listX, listY)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We generate grids with pixel size of 1x1 (and we centre it on the galaxy centre)</span>
        <span class="n">listX</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x0</span>
        <span class="n">listY</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">y0</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">listX</span><span class="p">,</span> <span class="n">listY</span><span class="p">)</span>
        <span class="n">intensity</span>          <span class="o">=</span> <span class="n">computeSersic</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">)</span>
        
        <span class="c1"># We generate a subarray around the centre in the given box, using the given over-sampling factor</span>
        <span class="n">maxX</span>               <span class="o">=</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fineSampling</span><span class="p">)</span> <span class="c1"># Weird but that&#39;s what comes out of a few diagrams</span>
        <span class="n">maxY</span>               <span class="o">=</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fineSampling</span><span class="p">)</span>
        <span class="n">listXcenPart</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxX</span><span class="p">,</span> <span class="n">maxX</span><span class="o">+</span><span class="n">pixWidth</span><span class="p">,</span> <span class="n">pixWidth</span><span class="p">)</span>
        <span class="n">listYcenPart</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxY</span><span class="p">,</span> <span class="n">maxY</span><span class="o">+</span><span class="n">pixHeight</span><span class="p">,</span> <span class="n">pixHeight</span><span class="p">)</span>
        
        <span class="n">XcenPart</span><span class="p">,</span> <span class="n">YcenPart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">listXcenPart</span><span class="p">,</span> <span class="n">listYcenPart</span><span class="p">)</span>
        <span class="n">intensityCenPart</span>   <span class="o">=</span> <span class="n">computeSersic</span><span class="p">(</span><span class="n">XcenPart</span><span class="p">,</span> <span class="n">YcenPart</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">)</span>

        <span class="c1"># Rebinning intensity map in the central part</span>
        <span class="n">intensityCenPart</span>   <span class="o">=</span> <span class="n">intensityCenPart</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">intensityCenPart</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">fineSampling</span><span class="p">),</span> <span class="n">fineSampling</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">intensityCenPart</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">fineSampling</span><span class="p">),</span> <span class="n">fineSampling</span><span class="p">)</span>
        <span class="n">intensityCenPart</span>   <span class="o">=</span> <span class="n">intensityCenPart</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">fineSampling</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Combining back the central part into the original array</span>
        <span class="n">intensity</span><span class="p">[</span><span class="n">y0</span><span class="o">-</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]:</span><span class="n">y0</span><span class="o">+</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]:</span><span class="n">x0</span><span class="o">+</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensityCenPart</span>
        
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">intensity</span></div>





</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">wilfried library</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../makeLifeSimpler.html">makeLifeSimpler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../galaxy/index.html">Galaxy module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../galfit/index.html">Galfit module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Wilfried Mercier.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>