
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>galaxy.models &#8212; wilfried library 1.0 documentation</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.e7340bb3dbd8dde6db86f25597f54a1b.css" type="text/css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  
  <h1 class="site-logo" id="site-title">wilfried library 1.0 documentation</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../index.html">
   Table of content
  </a>
 </li>
</ul>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../makeLifeSimpler.html">
   makeLifeSimpler
  </a>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../../galaxy/index.html">
   Galaxy module
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../../galaxy/angularMomentum.html">
     Galaxies angular momentum
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../galaxy/cosmology.html">
     Cosmology computations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../galaxy/kinematics.html">
     Galaxy kinematics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../galaxy/misc.html">
     Miscellaneous
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../galaxy/massModels.html">
     Galaxy mass models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../galaxy/models.html">
     Galaxy models
    </a>
   </li>
   <li class="toctree-l2 collapsible-parent">
    <a class="reference internal" href="../../galaxy/morphology/index.html">
     Galaxies morphology
    </a>
    <ul class="collapse-ul">
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/morphology/SersicFlux.html">
       Sersic fluxes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/morphology/Morpho.html">
       Morphological parameters
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/morphology/Thickness.html">
       Galaxies thickness
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/morphology/MUSE.html">
       MUSE related functions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/morphology/Other.html">
       Other Sersic related functions
      </a>
     </li>
    </ul>
    <i class="fas fa-chevron-down">
    </i>
   </li>
   <li class="toctree-l2 collapsible-parent">
    <a class="reference internal" href="../../galaxy/photometry/index.html">
     Galaxies photometry
    </a>
    <ul class="collapse-ul">
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/photometry/Fluxes.html">
       Fluxes, colour excess and attenuation
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../galaxy/photometry/Masses_SFR.html">
       Masses and SFR estimates
      </a>
     </li>
    </ul>
    <i class="fas fa-chevron-down">
    </i>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../../galfit/index.html">
   Galfit module
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../../galfit/galfit.html">
     Galfit auto-routines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../galfit/models.html">
     Galfit models
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/WilfriedMercier/wilfried"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <h1>Source code for galaxy.models</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>

<span class="sd">Useful functions for galaxy modelling and other related computation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>                              <span class="k">as</span>     <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">astropy.modeling.functional_models</span> <span class="k">as</span>     <span class="nn">astmod</span>
<span class="kn">from</span>   <span class="nn">.misc</span>                              <span class="kn">import</span> <span class="n">check_bns</span><span class="p">,</span> <span class="n">compute_bn</span><span class="p">,</span> <span class="n">PSFconvolution2D</span><span class="p">,</span> <span class="n">checkAndComputeIe</span><span class="p">,</span> <span class="n">intensity_at_re</span>
<span class="kn">from</span>   <span class="nn">astropy.constants</span>                  <span class="kn">import</span> <span class="n">G</span>

<span class="c1"># If Planck18 not available we use Planck15</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">astropy.cosmology</span>                <span class="kn">import</span> <span class="n">Planck18</span> <span class="k">as</span> <span class="n">cosmo</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">astropy.cosmology</span>                <span class="kn">import</span> <span class="n">Planck15</span> <span class="k">as</span> <span class="n">cosmo</span>



<span class="c1">####################################################################################################################</span>
<span class="c1">#                                           1D profiles                                                            #</span>
<span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="bulge"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.bulge">[docs]</a><span class="k">def</span> <span class="nf">bulge</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">b4</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Computes the value of the intensity of a de Vaucouleur bulge at position r defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \Sigma(r) = I_{\rm{e}} e^{\left [ \left (r/R_{\rm{e}} \right )^{1/4} - 1 \right ]},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`R_{\rm{e}}` the effective radius and :math:`I_{\rm{e}}` the surface brightness at the effective radius.</span>

<span class="sd">    :param float r: position at which the profile is computed</span>
<span class="sd">    :param float re: half-light radius</span>
<span class="sd">                </span>
<span class="sd">    :param float b4: (**Optional**) b4 factor appearing in the Sersic profile. If None, its value will be computed.</span>
<span class="sd">    :param float Ie: (**Optional**) surface brightness at half-light radius</span>
<span class="sd">    :param float mag: (**Optional**) total integrated magnitude used to compute Ie if not given</span>
<span class="sd">    :param float offset: (**Optional**) magnitude offset in the magnitude system used</span>
<span class="sd">        </span>
<span class="sd">    :returns: surface brightness</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">b4</span><span class="p">,</span> <span class="o">=</span> <span class="n">check_bns</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">b4</span><span class="p">])</span>
    <span class="n">Ie</span>  <span class="o">=</span> <span class="n">checkAndComputeIe</span><span class="p">(</span><span class="n">Ie</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b4</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sersic_profile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="n">Ie</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">b4</span><span class="p">)</span></div>


<div class="viewcode-block" id="exponential_disk"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.exponential_disk">[docs]</a><span class="k">def</span> <span class="nf">exponential_disk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Computes the value of the intensity of an exponential disk at position r defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \Sigma(r) = I_{\rm{e}} e^{\left [ r/R_{\rm{e}} - 1 \right ]},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`R_{\rm{e}}` the effective radius and :math:`I_{\rm{e}}` the surface brightness at the effective radius.</span>
<span class="sd">    </span>
<span class="sd">    :param float r: position at which the profile is computed</span>
<span class="sd">    :param float re: half-light radius</span>
<span class="sd">                </span>
<span class="sd">    :param float b1: (**Optional**) b1 factor appearing in the Sersic profile. If None, its value will be computed.</span>
<span class="sd">    :param float Ie: (**Optional**) surface brightness at half-light radius</span>
<span class="sd">    :param float mag: (**Optional**) total integrated magnitude used to compute Ie if not given</span>
<span class="sd">    :param float offset: (**Optional**) magnitude offset in the magnitude system used</span>
<span class="sd">        </span>
<span class="sd">    :returns: surface brightness</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">b1</span><span class="p">,</span> <span class="o">=</span> <span class="n">check_bns</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">b1</span><span class="p">])</span>
    <span class="n">Ie</span>  <span class="o">=</span> <span class="n">checkAndComputeIe</span><span class="p">(</span><span class="n">Ie</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sersic_profile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="n">Ie</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">b1</span><span class="p">)</span></div>


<div class="viewcode-block" id="hernquist"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.hernquist">[docs]</a><span class="k">def</span> <span class="nf">hernquist</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Hernquist profile defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \rho(r) = \frac{M_{\rm{b}}}{2\pi} \frac{a}{r} (r + a)^{-3},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`M_{\rm{b}}` the total mass and :math:`a` the scale radius.</span>

<span class="sd">    :param a: scale radius</span>
<span class="sd">    :type a: int or float</span>
<span class="sd">    :param M: total mass</span>
<span class="sd">    :type M: int or float</span>
<span class="sd">    :param r: radial distance(s) where to compute the Hernquist profile. Unit must be the same as **a**.</span>
<span class="sd">    :type r: int or float or ndarray[int] or ndarray[float]</span>

<span class="sd">    :returns: Hernquist profile evaluated at the given distance(s). Unit is that of **M**/**a^3**.</span>
<span class="sd">    :rtype: float or ndarray[float]</span>
<span class="sd">    </span>
<span class="sd">    :raises TypeError: if **r**, **M** and **a** are neither int, nor float</span>
<span class="sd">    :raises ValueError: if np.any(**r**) &lt; 0, if **a** &lt;= 0 or if **M** &lt; 0</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Checking dtypes and values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span>   <span class="n">r</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;r must either be int or float, or a numpy array of the same types. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;M must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;a must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">a</span><span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a must be positive only. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span>   <span class="n">M</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">*</span><span class="n">r</span>
    <span class="k">elif</span> <span class="n">M</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;M must be positive only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="n">out</span>        <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="nfw"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.nfw">[docs]</a><span class="k">def</span> <span class="nf">nfw</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">rs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    NFW profile defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \rho(r) = \delta_{\rm{c}} \rho_{\rm{crit}} (r/r_{\rm{s}})^{-1} (1 + r/r_{\rm{s}})^{-2},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`r_{\rm{s}} = r_{200} / c` the halo scale radius, with :math:`r_{200}` the virial radius where the mean overdensity is equal to 200, :math:`c` the halo concentration, :math:`\rho_{\rm{crit}} = 3 H_0^2 / (8\pi G)` the Universe closure density, and :math:`\delta_{\rm{c}}` the halo overdensity.</span>

<span class="sd">    :param c: halo concentration</span>
<span class="sd">    :type c: int or float</span>
<span class="sd">    :param r: radial distance(s) where to compute the profile. Unit must be the same as rs.</span>
<span class="sd">    :type r: int or float or ndarray[int] or ndarray[float]</span>
<span class="sd">    :param rs: scale radius</span>
<span class="sd">    :type rs: int or float</span>
<span class="sd">        </span>
<span class="sd">    :returns: NFW profile evaluated at the given distance. Unit is that of a 3D mass density in SI (i.e. kg/m^3).</span>
<span class="sd">    :rtype: float or ndarray[float]</span>
<span class="sd">    </span>
<span class="sd">    :raises TypeError: if **r**, **c** and **rs** are neither int, nor float</span>
<span class="sd">    :raises ValueError: if np.any(**r**)&lt;0, if c&lt;=0, or if rs&lt;=0</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Checking dtypes and values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span>   <span class="n">r</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r must be positive only. Cheers !&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;r must either be int or float, or a numpy array of the same types. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;c must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;rs must be int or float only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;c must be positive only. Cheers !&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">rs</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rs must be positive only. Cheers !&#39;</span><span class="p">)</span>
    
    <span class="n">deltaC</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">200</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="p">))</span>
    <span class="n">rhoCrit</span>    <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">cosmo</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">G</span><span class="p">)</span>
    <span class="n">out</span>        <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaC</span><span class="o">*</span><span class="n">rhoCrit</span> <span class="o">/</span> <span class="p">((</span><span class="n">r</span><span class="o">/</span><span class="n">rs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">r</span><span class="o">/</span><span class="n">rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="sersic_profile"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.sersic_profile">[docs]</a><span class="k">def</span> <span class="nf">sersic_profile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">Ie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    General Sersic profile defined as </span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        \Sigma(r) = I_{\rm{e}} e^{\left [ \left (r/R_{\rm{e}} \right )^{1/n} - 1 \right ]},</span>
<span class="sd">    </span>
<span class="sd">    with :math:`R_{\rm{e}}` the effective radius, :math:`I_{\rm{e}}` the surface brightness at the effective radius and :math:`n` the Sersic index.</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        </span>
<span class="sd">        Compute it with:</span>
<span class="sd">            </span>
<span class="sd">            * n, re and Ie</span>
<span class="sd">            * n, re, mag and offset</span>
<span class="sd">            </span>
<span class="sd">    :param float r: position at which the profile is computed</span>
<span class="sd">    :param float re: half-light radius</span>
<span class="sd">                </span>
<span class="sd">    :param float bn: (**Optional**) bn factor appearing in the Sersic profile. If None, its value will be computed.</span>
<span class="sd">    :param float Ie: (**Optional**) surface brightness at half-light radius</span>
<span class="sd">    :param float mag: (**Optional**) total integrated magnitude used to compute Ie if not given</span>
<span class="sd">    :param float offset: (**Optional**) magnitude offset in the magnitude system used</span>
<span class="sd">        </span>
<span class="sd">    :returns: surface brightness</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">bn</span><span class="p">,</span> <span class="o">=</span> <span class="n">check_bns</span><span class="p">([</span><span class="n">n</span><span class="p">],</span> <span class="p">[</span><span class="n">bn</span><span class="p">])</span>
    <span class="n">Ie</span>  <span class="o">=</span> <span class="n">checkAndComputeIe</span><span class="p">(</span><span class="n">Ie</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Ie</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="n">bn</span><span class="o">*</span><span class="p">((</span><span class="n">r</span><span class="o">/</span><span class="n">re</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span></div>


<span class="c1">####################################################################################################</span>
<span class="c1">#                                      2D modelling                                                #</span>
<span class="c1">####################################################################################################</span>

<span class="k">def</span> <span class="nf">_checkParams</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">samplingZone</span><span class="p">,</span> <span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;&#39;Check that given parameters are ok.&#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;where&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sampling zone was not provided or syntax was incorrect. Thus, performing sampling (if relevant) on the full array.&#39;</span><span class="p">)</span>
            
        <span class="n">samplingZone</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;all&#39;</span><span class="p">}</span>
        
    <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;centre&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;where&#39; keyword in samplingZone dictionnary should be either &#39;all&#39; or &#39;centre&#39;. Cheers !&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;centre&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span> <span class="ow">or</span> <span class="s1">&#39;dy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samplingZone</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;&#39;dx&#39; and &#39;dy&#39; keywords were missing in samplingZone dictionnary with &#39;where&#39; keyword equal to &#39;centre&#39;. Please provide values for the sampling box size around the centre. Cheers !&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;At least one of the following keys in samplingZone dictionnary was not given as an integer: &#39;dx&#39; or &#39;dy&#39;. Please provide these as int. Cheers !&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fineSampling</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;One of the following parameter is not an integer, which is not valid: fineSampling (</span><span class="si">%s</span><span class="s1">), nx (</span><span class="si">%s</span><span class="s1">), ny (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fineSampling</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">fineSampling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Fine sampling cannot be less than 1.&#39;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">samplingZone</span>


<div class="viewcode-block" id="bulgeDiskOnSky"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.bulgeDiskOnSky">[docs]</a><span class="k">def</span> <span class="nf">bulgeDiskOnSky</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magD</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offsetD</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offsetB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclination</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">PA</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">PSF</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;Gaussian2D&#39;</span><span class="p">,</span> <span class="s1">&#39;FWHMX&#39;</span><span class="p">:</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;FWHMY&#39;</span><span class="p">:</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;sigmaX&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sigmaY&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span><span class="s1">&#39;arcsec&#39;</span><span class="p">},</span> <span class="n">noPSF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
                   <span class="n">fineSampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;centre&#39;</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">},</span> <span class="n">skipCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Generate a bulge + (sky projected) disk 2D model (with PSF convolution).</span>
<span class="sd">    </span>
<span class="sd">    .. rubric:: **How to use**</span>
<span class="sd">        </span>
<span class="sd">    Apart from the mandatory inputs, it is necessary to provide</span>

<span class="sd">    * an intensity at Re for each profile</span>
<span class="sd">    * a total magnitude value for each profile and a corresponding magnitude offset per profile (to convert from magnitudes to intensities)</span>
<span class="sd">   </span>
<span class="sd">    .. rubric:: **Infos about sampling** </span>
<span class="sd">   </span>
<span class="sd">    **fineSampling** parameter can be used to rebin the data. The shape of the final image will depend on the samplingZone used</span>
<span class="sd">    </span>
<span class="sd">    * if the sampling is performed everywhere (&#39;where&#39; keyword in **samplingZone** equal to &#39;all&#39;), the final image will have dimensions (**nx*fineSampling**, **ny*fineSampling**)</span>
<span class="sd">    * if the sampling is performed around the centre (&#39;where&#39; equal to &#39;centre&#39;), the central part is over-sampled, but needs to be binned in the end so that pixels have the same size in the central part and around. Thus, the final image will have the dimension (**nx**, **ny**).        </span>
<span class="sd">       </span>
<span class="sd">    .. warning::</span>
<span class="sd">        </span>
<span class="sd">        **Rd** and **Rb** should be given in pixel units. </span>
<span class="sd">        </span>
<span class="sd">        If you provide them in arcsec, you must update the **arcsecToGrid** value to 1 (since 1 pixel will be equal to 1 arcsec). </span>
<span class="sd">    </span>
<span class="sd">    :param int nx: size of the model for the x-axis</span>
<span class="sd">    :param int ny: size of the model for the y-axis</span>
<span class="sd">    :param float Rb: bulge half-light radius. Best practice is to provide it in pixels.</span>
<span class="sd">    :param float Rd: disk half-light radius. Best practice is to provide it in pixels.</span>

<span class="sd">    :param float arcsecToGrid: (**Optional**) pixel size conversion in arcsec/pixel, used to convert the FWHM/sigma from arcsec to pixel      </span>
<span class="sd">    :param float Ib: (**Optional**) bulge intensity at (bulge) half-light radius. If not provided, magnitude and magnitude offset must be given instead.</span>
<span class="sd">    :param float Id: (**Optional**) disk intensity at (disk) half-light radius. If not provided, magnitude and magnitude offset must be given instead.</span>
<span class="sd">    :param inclination: (**Optional**) disk inclination on sky. Generally given between -90° and +90°. Value must be given in degrees.</span>
<span class="sd">    :type inclination: (**Optional**) int or float</span>
<span class="sd">    :param float magB: (**Optional**) bulge total magnitude</span>
<span class="sd">    :param float magD: (**Optional**) disk total magnitude</span>
<span class="sd">    :param float offsetB: (**Optional**) bulge magnitude offset</span>
<span class="sd">    :param float offsetD: (**Optional**) disk magnitude offset</span>
<span class="sd">    :param bool noPSF: (**Optional**) whether to not perform PSF convolution or not</span>
<span class="sd">    :param PA: disk position angle (in degrees)</span>
<span class="sd">    :type PA: int or float</span>
<span class="sd">    :param int(&gt;0) fineSampling: fine sampling for the pixel grid used to make high resolution models. For instance, a value of 2 means that a pixel will be split into two subpixels.</span>
<span class="sd">    :param dict PSF: (**Optional**) Dictionnary of the PSF (and its parameters) to use for the convolution. For now, only 2D Gaussians are accepted as PSF. </span>
<span class="sd">    :param dict samplingZone: where to perform the over sampling. Dictionnaries should have the following keys:</span>
<span class="sd">    </span>
<span class="sd">        * &#39;where&#39; (type str) -&gt; either &#39;all&#39; to perform everywhere or &#39;centre&#39; to perform around the centre</span>
<span class="sd">        * &#39;dx&#39;    (type int) -&gt; x-axis maximum distance from the centre coordinate. A sub-array with x-axis values within [xpos-dx, xpos+dx] will be selected. If the sampling is performed everywhere, &#39;dx&#39; does not need to be provided.</span>
<span class="sd">        * &#39;dy&#39;    (type int) -&gt; y-axis maximum distance from the centre coordinate. A sub-array with y-axis values within [ypos-dy, ypos+dy] will be selected. If the sampling is performed everywhere, &#39;dy&#39; does not need to be provided.</span>
<span class="sd">               </span>
<span class="sd">    :param bool skipCheck: whether to skip the checking part or not</span>
<span class="sd">    :param x0: x-axis centre position. Default is None so that nx//2 will be used.</span>
<span class="sd">    :type x0: int or float</span>
<span class="sd">    :param y0: y-axis centre position. Default is None so that ny//2 will be used.</span>
<span class="sd">    :type y0: int or float</span>
<span class="sd">    :param bool verbose: whether to print text on stdout or not</span>
<span class="sd">    </span>
<span class="sd">    :returns: X, Y grids and the total (sky projected + PSF convolved) model of the bulge + disk decomposition</span>
<span class="sd">    :rtype: 2D ndarray, 2D ndarray, 2D ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1">##############################################</span>
    <span class="c1">#          Checking input parameters         #</span>
    <span class="c1">##############################################</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipCheck</span><span class="p">:</span>
        <span class="n">samplingZone</span> <span class="o">=</span> <span class="n">_checkParams</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">samplingZone</span><span class="p">,</span> <span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one of the following parameters was provided as a negative number, which is not correct: nx, ny, Rb, Rd, arcsecToGrid.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">PA</span><span class="o">&lt;-</span><span class="mi">90</span> <span class="ow">or</span> <span class="n">PA</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;PA should be given in the range -90° &lt;= PA &lt;= 90°, counting angles anti clock-wise (0° means major axis is vetically aligned). Cheers !&#39;</span><span class="p">)</span>
       
    <span class="c1">##################################</span>
    <span class="c1">#         Compute models         #</span>
    <span class="c1">##################################</span>

    <span class="n">listn</span>       <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="n">listbn</span>      <span class="o">=</span> <span class="p">[</span><span class="n">compute_bn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">listn</span><span class="p">]</span>

    <span class="c1"># Checking that we have the correct information to model correctly our data    </span>
    <span class="k">if</span> <span class="n">Id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">magD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offsetD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Id</span>  <span class="o">=</span> <span class="n">intensity_at_re</span><span class="p">(</span><span class="n">listn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">magD</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">offsetD</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">listbn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Id is None, but magD or offsetD is also None. If no Id is given, please provide a value for the total magnitude and magnitude offset in order to compute the intensity. Cheers !&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">Ib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">magB</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offsetB</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Ib</span>  <span class="o">=</span> <span class="n">intensity_at_re</span><span class="p">(</span><span class="n">listn</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">magB</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">offsetB</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="n">listbn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ib is None, but magB or offsetB is also None. If no Ib is given, please provide a value for the total magnitude and magnitude offset in order to compute the intensity. Cheers !&quot;</span><span class="p">)</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">Sersic2D</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="p">[</span><span class="n">Rd</span><span class="p">,</span> <span class="n">Rb</span><span class="p">],</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">listIe</span><span class="o">=</span><span class="p">[</span><span class="n">Id</span><span class="p">,</span> <span class="n">Ib</span><span class="p">],</span> <span class="n">listInclination</span><span class="o">=</span><span class="p">[</span><span class="n">inclination</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">listPA</span><span class="o">=</span><span class="p">[</span><span class="n">PA</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fineSampling</span><span class="o">=</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="n">samplingZone</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">noPSF</span><span class="p">:</span>
        <span class="c1"># If we perform fine sampling only in the central part, Sersic2D function rebins the data in the end, so the arcsec to pixel conversion factor does not need to be updated since we do not have a finer pixel scale</span>
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;centre&#39;</span><span class="p">:</span>
            <span class="n">fineSampling</span>   <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">model</span>          <span class="o">=</span> <span class="n">PSFconvolution2D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">PSF</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="n">arcsecToGrid</span><span class="o">/</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mod</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                <span class="n">model</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">PSFconvolution2D</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">PSF</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="n">arcsecToGrid</span><span class="o">/</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span></div>


<div class="viewcode-block" id="bulge2D"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.bulge2D">[docs]</a><span class="k">def</span> <span class="nf">bulge2D</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclination</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">PA</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
            <span class="n">PSF</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;Gaussian2D&#39;</span><span class="p">,</span> <span class="s1">&#39;FWHMX&#39;</span><span class="p">:</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;FWHMY&#39;</span><span class="p">:</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;sigmaX&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sigmaY&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span><span class="s1">&#39;arcsec&#39;</span><span class="p">},</span> <span class="n">noPSF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
            <span class="n">fineSampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;centre&#39;</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">},</span> <span class="n">skipCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Generate a 2D model for a de Vaucouleur bulge. This model can be sky projected and PSF convolved.</span>
<span class="sd">    </span>
<span class="sd">    .. rubric:: **How to use**</span>
<span class="sd">    </span>
<span class="sd">    You must provide the size of the image with **nx** and **ny** as well as a bulge effective radius (usually in pixel unit) with **Rb**. Additionally, one must provide one of the following</span>
<span class="sd">    </span>
<span class="sd">    * surface brightness at **Rb** with **Ib**</span>
<span class="sd">    * total magnitude and magnitude offset to go from magnitude to **Ie** using the parameters **mag** and **offset**</span>
<span class="sd">    </span>
<span class="sd">    The PSF convolution only accepts 2D Gaussians for now. You can either provide</span>
<span class="sd">    </span>
<span class="sd">    * a FWHM in the X and Y directions</span>
<span class="sd">    * a dispersion in the X and Y directions</span>
<span class="sd">    </span>
<span class="sd">    You must also provide a unit for the FWHM or sigma values. This unit must be recognised by astropy. Since images have dimensions in pixel unit, if the FWHM or sigma values are not given in pixel unit, you must also provide :samp:`arcsecToGrid` to convert from physical unit to pixel unit.</span>
<span class="sd">    </span>
<span class="sd">    If you do not want to convolve with the PSF, provide :samp:`noPSF=True`.</span>
<span class="sd">    </span>
<span class="sd">    .. rubric: **Infos about sampling** </span>
<span class="sd">  </span>
<span class="sd">    **fineSampling** parameter can be used to rebin the data. The shape of the final image will depend on the samplingZone used</span>
<span class="sd">        </span>
<span class="sd">    * if the sampling is performed everywhere (&#39;where&#39; keyword in **samplingZone** equal to &#39;all&#39;), the final image will have dimensions (**nx*fineSampling**, **ny*fineSampling**)</span>
<span class="sd">    * if the sampling is performed around the centre (&#39;where&#39; equal to &#39;centre&#39;), the central part is over-sampled, but needs to be binned in the end so that pixels have the same size in the central part and around. Thus, the final image will have the dimension (**nx**, **ny**).        </span>

<span class="sd">    :param int nx: size of the model for the x-axis</span>
<span class="sd">    :param int ny: size of the model for the y-axis</span>
<span class="sd">    :param float Rb: bulge half-light radius. Best practice is to provide it in pixels.</span>
<span class="sd">    :param x0: (**Optional**) x-axis centre position. Default is None so that **nx**//2 will be used.</span>
<span class="sd">    :type x0: int or float</span>
<span class="sd">    :param y0: (**Optional**) y-axis centre position. Default is None so that **ny**//2 will be used.</span>
<span class="sd">    :type y0: int or float</span>
<span class="sd">    :param float Ib: (**Optional**) bulge intensity at (bulge) half-light radius. If not provided, magnitude and magnitude offset must be given instead.</span>
<span class="sd">    :param float magB: (**Optional**) bulge total magnitude</span>
<span class="sd">    :param float offsetB: (**Optional**) bulge magnitude offset</span>
<span class="sd">    :param inclination: (**Optional**) inclination on sky. Generally given between -90° and +90°. Value must be given in degrees.</span>
<span class="sd">    :type inclination: (**Optional**) int or float</span>
<span class="sd">    :param PA: position angle (in degrees)</span>
<span class="sd">    :type PA: int or float</span>
<span class="sd">    :param dict PSF: (**Optional**) Dictionnary of the PSF (and its parameters) to use for the convolution. For now, only 2D Gaussians are accepted as PSF. </span>
<span class="sd">    :param bool noPSF: (**Optional**) whether to not perform PSF convolution or not</span>
<span class="sd">    :param float arcsecToGrid: (**Optional**) pixel size conversion in arcsec/pixel, used to convert the FWHM/sigma from arcsec to pixel      </span>
<span class="sd">    :param int(&gt;0) fineSampling: fine sampling for the pixel grid used to make high resolution models. For instance, a value of 2 means that a pixel will be split into two subpixels.</span>
<span class="sd">    :param dict samplingZone: where to perform the over sampling. Dictionnaries should have the following keys:</span>
<span class="sd">    </span>
<span class="sd">        * &#39;where&#39; (type str) -&gt; either &#39;all&#39; to perform everywhere or &#39;centre&#39; to perform around the centre</span>
<span class="sd">        * &#39;dx&#39;    (type int) -&gt; x-axis maximum distance from the centre coordinate. A sub-array with x-axis values within [xpos-dx, xpos+dx] will be selected. If the sampling is performed everywhere, &#39;dx&#39; does not need to be provided.</span>
<span class="sd">        * &#39;dy&#39;    (type int) -&gt; y-axis maximum distance from the centre coordinate. A sub-array with y-axis values within [ypos-dy, ypos+dy] will be selected. If the sampling is performed everywhere, &#39;dy&#39; does not need to be provided.</span>
<span class="sd">               </span>
<span class="sd">    :param bool skipCheck: whether to skip the checking part or not</span>
<span class="sd">    :param bool verbose: (**Optional**) whether to print info on stdout or not</span>
<span class="sd">    </span>
<span class="sd">    :returns: X coordinate array, Y coordinate array and the 2D bulge model</span>
<span class="sd">    :rtype: 2D ndarray[float], 2D ndarray[float], 2D ndarray[float]</span>
<span class="sd">   </span>
<span class="sd">    .. rubric:: **Example**</span>
<span class="sd">    </span>
<span class="sd">    Comparing different models:</span>
<span class="sd">        </span>
<span class="sd">    * The first does not use **fineSampling**, thus it shows an intensity profile, rather than a flux profile</span>
<span class="sd">    * The second one uses :samp:`fineSampling=81` so that it matches more the ouput of `Galfit &lt;https://users.obs.carnegiescience.edu/peng/work/galfit/galfit.html&gt;`_</span>
<span class="sd">    * The last one also uses **fineSampling** but is convolved by a Gaussian with :math:`{\rm{FWHM}} = 0.087~\rm{arcsec}`</span>
<span class="sd">    </span>
<span class="sd">    .. plot::</span>
<span class="sd">        :include-source:</span>
<span class="sd">                    </span>
<span class="sd">        from   matplotlib.colors   import LogNorm</span>
<span class="sd">        from   matplotlib          import rc</span>
<span class="sd">        from   matplotlib.gridspec import GridSpec</span>
<span class="sd">        from   wilfried.galaxy     import models as mod</span>
<span class="sd">        import matplotlib.pyplot   as     plt</span>
<span class="sd">        import matplotlib          as     mpl</span>
<span class="sd">        </span>
<span class="sd">        # Bulge model using fine sampling and without PSF</span>
<span class="sd">        X, Y, bulge1 = mod.bulge2D(100, 100, 35, mag=20, offset=30, noPSF=True)</span>
<span class="sd">        </span>
<span class="sd">        # Bulge mode with fine sampling but without PSF</span>
<span class="sd">        X, Y, bulge2 = mod.bulge2D(100, 100, 35, mag=20, offset=30, noPSF=True, fineSampling=81)</span>
<span class="sd">        </span>
<span class="sd">        # Bulge model with fine sampling and with PSF convolution (FWHM=0.8 arcsec)</span>
<span class="sd">        X, Y, bulge3 = mod.bulge2D(100, 100, 35, mag=20, offset=30, noPSF=False, fineSampling=81,</span>
<span class="sd">                                  PSF={&#39;name&#39;:&#39;Gaussian2D&#39;, &#39;FWHMX&#39;:0.8, &#39;FWHMY&#39;:0.8, &#39;unit&#39;:&#39;arcsec&#39;}, arcsecToGrid=0.03)</span>
<span class="sd">        </span>
<span class="sd">        ###############################</span>
<span class="sd">        #          Plot part          #</span>
<span class="sd">        ###############################</span>
<span class="sd">        </span>
<span class="sd">        # Setup figure and axes</span>
<span class="sd">        rc(&#39;font&#39;, **{&#39;family&#39;: &#39;serif&#39;, &#39;serif&#39;: [&#39;Times&#39;]})</span>
<span class="sd">        rc(&#39;text&#39;, usetex=True)</span>
<span class="sd">        mpl.rcParams[&#39;text.latex.preamble&#39;] = r&#39;\usepackage{newtxmath}&#39;</span>
<span class="sd">        </span>
<span class="sd">        f            = plt.figure(figsize=(9, 3))</span>
<span class="sd">        gs           = GridSpec(1, 3, figure=f, wspace=0, hspace=0, left=0.2, right=0.8, top=0.9, bottom=0.3)</span>
<span class="sd">        </span>
<span class="sd">        ax1          = f.add_subplot(gs[0])</span>
<span class="sd">        ax2          = f.add_subplot(gs[1])</span>
<span class="sd">        ax3          = f.add_subplot(gs[2])</span>
<span class="sd">        </span>
<span class="sd">        ax1.set_title(r&#39;No fine sampling&#39;,      size=15)</span>
<span class="sd">        ax2.set_title(r&#39;Fine sampling = $9^2$&#39;, size=15)</span>
<span class="sd">        ax3.set_title(r&#39;Fine sampling \&amp; PSF&#39;,  size=15)</span>
<span class="sd">        </span>
<span class="sd">        for a in [ax1, ax2, ax3]:</span>
<span class="sd">           a.set_xticklabels([])</span>
<span class="sd">           a.set_yticklabels([])</span>
<span class="sd">           a.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, direction=&#39;in&#39;)</span>
<span class="sd">           a.tick_params(axis=&#39;y&#39;, which=&#39;both&#39;, direction=&#39;in&#39;)</span>
<span class="sd">           a.yaxis.set_ticks_position(&#39;both&#39;)</span>
<span class="sd">           a.xaxis.set_ticks_position(&#39;both&#39;)</span>
<span class="sd">        </span>
<span class="sd">        # Show bulges</span>
<span class="sd">        ret1  = ax1.imshow(bulge1, origin=&#39;lower&#39;, norm=LogNorm(), cmap=&#39;plasma&#39;)</span>
<span class="sd">        ret2  = ax2.imshow(bulge2, origin=&#39;lower&#39;, norm=LogNorm(), cmap=&#39;plasma&#39;)</span>
<span class="sd">        ret3  = ax3.imshow(bulge3, origin=&#39;lower&#39;, norm=LogNorm(), cmap=&#39;plasma&#39;)</span>
<span class="sd">        </span>
<span class="sd">        # Add colorbar</span>
<span class="sd">        cb_ax = f.add_axes([0.2, 0.2, 0.6, 0.025])</span>
<span class="sd">        cbar  = f.colorbar(ret1, cax=cb_ax, orientation=&#39;horizontal&#39;)</span>
<span class="sd">        cbar.set_label(r&#39;Surface brightness [arbitrary unit]&#39;, size=15)</span>
<span class="sd">        cbar.ax.tick_params(labelsize=15)</span>
<span class="sd">        </span>
<span class="sd">        plt.show()</span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    .. rubric:: **Comparison with Galfit models**</span>

<span class="sd">    We can also compare the ouput from this function with a similar model made with `Galfit &lt;https://users.obs.carnegiescience.edu/peng/work/galfit/galfit.html&gt;`_:</span>
<span class="sd">        </span>
<span class="sd">    .. plot::</span>
<span class="sd">        :include-source:</span>
<span class="sd">            </span>
<span class="sd">        from   matplotlib.colors   import LogNorm, Normalize</span>
<span class="sd">        from   matplotlib          import rc</span>
<span class="sd">        from   matplotlib.gridspec import GridSpec</span>
<span class="sd">        from   astropy.io          import fits</span>
<span class="sd">        from   wilfried.galaxy     import models as mod</span>
<span class="sd">        import matplotlib.pyplot   as     plt</span>
<span class="sd">        import matplotlib          as     mpl</span>
<span class="sd">        import numpy               as     np</span>
<span class="sd">        </span>
<span class="sd">        ##############################</span>
<span class="sd">        #     Generate 2D models     #</span>
<span class="sd">        ##############################</span>
<span class="sd">        </span>
<span class="sd">        X, Y, bulge1 = mod.bulge2D(100, 100, 15, mag=21, offset=30, noPSF=True,  fineSampling=81, samplingZone={&#39;where&#39;:&#39;centre&#39;, &#39;dx&#39;:5, &#39;dy&#39;:5})</span>
<span class="sd">        X, Y, bulge2 = mod.bulge2D(100, 100, 15, mag=21, offset=30, noPSF=False, fineSampling=81, samplingZone={&#39;where&#39;:&#39;centre&#39;, &#39;dx&#39;:5, &#39;dy&#39;:5},</span>
<span class="sd">                                  PSF={&#39;name&#39;:&#39;Gaussian2D&#39;, &#39;FWHMX&#39;:0.087, &#39;FWHMY&#39;:0.087, &#39;unit&#39;:&#39;arcsec&#39;}, arcsecToGrid=0.03)</span>
<span class="sd">        </span>
<span class="sd">        #####################################</span>
<span class="sd">        #     Load GALFIT output images     #</span>
<span class="sd">        #####################################</span>
<span class="sd">        </span>
<span class="sd">        with fits.open(&#39;/home/wilfried/wilfried_libs/galaxy/.test/bulge_withoutPSF.fits&#39;) as hdul:</span>
<span class="sd">           bulge_nopsf = hdul[0].data</span>
<span class="sd">        </span>
<span class="sd">        with fits.open(&#39;/home/wilfried/wilfried_libs/galaxy/.test/bulge_withPSF.fits&#39;) as hdul:</span>
<span class="sd">           bulge_psf   = hdul[0].data</span>
<span class="sd">        </span>
<span class="sd">        ##########################</span>
<span class="sd">        #       Plot parts       #</span>
<span class="sd">        ##########################</span>
<span class="sd">        </span>
<span class="sd">        rc(&#39;font&#39;, **{&#39;family&#39;: &#39;serif&#39;, &#39;serif&#39;: [&#39;Times&#39;]})</span>
<span class="sd">        rc(&#39;text&#39;, usetex=True)</span>
<span class="sd">        mpl.rcParams[&#39;text.latex.preamble&#39;] = r&#39;\usepackage{newtxmath}&#39;</span>
<span class="sd">        </span>
<span class="sd">        f            = plt.figure(figsize=(9, 6))</span>
<span class="sd">        gs           = GridSpec(2, 3, figure=f, wspace=0, hspace=0, left=0.1, right=0.9, top=0.95, bottom=0.15)</span>
<span class="sd">        </span>
<span class="sd">        axs          = []</span>
<span class="sd">        for i in gs:</span>
<span class="sd">           axs.append(f.add_subplot(i))</span>
<span class="sd">        </span>
<span class="sd">        axs[0].set_ylabel(r&#39;without PSF&#39;, size=15)</span>
<span class="sd">        axs[0].set_title(r&#39;bulge2D&#39;,      size=15)</span>
<span class="sd">        axs[1].set_title(r&#39;Galfit bulge&#39;, size=15)</span>
<span class="sd">        axs[2].set_title(r&#39;Residuals&#39;,    size=15)</span>
<span class="sd">        axs[3].set_ylabel(r&#39;with PSF&#39;,    size=15)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        for a in axs:</span>
<span class="sd">           a.set_xticklabels([])</span>
<span class="sd">           a.set_yticklabels([])</span>
<span class="sd">        </span>
<span class="sd">           a.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, direction=&#39;in&#39;)</span>
<span class="sd">           a.tick_params(axis=&#39;y&#39;, which=&#39;both&#39;, direction=&#39;in&#39;)</span>
<span class="sd">           a.yaxis.set_ticks_position(&#39;both&#39;)</span>
<span class="sd">           a.xaxis.set_ticks_position(&#39;both&#39;)</span>
<span class="sd">        </span>
<span class="sd">        # First line</span>
<span class="sd">        mmax  = np.nanmax([bulge1, bulge2, bulge_nopsf, bulge_psf])</span>
<span class="sd">        mmin  = np.nanmin([bulge1, bulge2, bulge_nopsf, bulge_psf])</span>
<span class="sd">        </span>
<span class="sd">        diff1 = 100 - 100*bulge_nopsf/bulge1</span>
<span class="sd">        diff2 = 100 - 100*bulge_psf/bulge2</span>
<span class="sd">        dmax  = np.nanmax([diff1, diff2])</span>
<span class="sd">        dmin  = np.nanmin([diff1, diff2])</span>
<span class="sd">        </span>
<span class="sd">        ret11 = axs[0].imshow(bulge1,      origin=&#39;lower&#39;, cmap=&#39;plasma&#39;,  norm=LogNorm(  vmin=mmin, vmax=mmax))</span>
<span class="sd">        ret12 = axs[1].imshow(bulge_nopsf, origin=&#39;lower&#39;, cmap=&#39;plasma&#39;,  norm=LogNorm(  vmin=mmin, vmax=mmax))</span>
<span class="sd">        ret13 = axs[2].imshow(diff1,       origin=&#39;lower&#39;, cmap=&#39;viridis&#39;, norm=Normalize(vmin=dmin, vmax=dmax))</span>
<span class="sd">        </span>
<span class="sd">        # Second line</span>
<span class="sd">        ret21 = axs[3].imshow(bulge2,      origin=&#39;lower&#39;, cmap=&#39;plasma&#39;,  norm=LogNorm(  vmin=mmin, vmax=mmax))</span>
<span class="sd">        ret22 = axs[4].imshow(bulge_psf,   origin=&#39;lower&#39;, cmap=&#39;plasma&#39;,  norm=LogNorm(  vmin=mmin, vmax=mmax))</span>
<span class="sd">        ret23 = axs[5].imshow(diff2,       origin=&#39;lower&#39;, cmap=&#39;viridis&#39;, norm=Normalize(vmin=dmin, vmax=dmax))</span>
<span class="sd">        </span>
<span class="sd">        # Add colorbar 1</span>
<span class="sd">        cb_ax1 = f.add_axes([0.1, 0.1, 0.53, 0.025])</span>
<span class="sd">        cbar1  = f.colorbar(ret11, cax=cb_ax1, orientation=&#39;horizontal&#39;)</span>
<span class="sd">        cbar1.set_label(r&#39;Surface brightness [arbitrary unit]&#39;, size=15)</span>
<span class="sd">        cbar1.ax.tick_params(labelsize=15)</span>
<span class="sd">        </span>
<span class="sd">        # Add colorbar 2</span>
<span class="sd">        cb_ax2 = f.add_axes([0.64, 0.1, 0.26, 0.025])</span>
<span class="sd">        cbar2  = f.colorbar(ret13, cax=cb_ax2, orientation=&#39;horizontal&#39;)</span>
<span class="sd">        cbar2.set_label(r&#39;Relative difference (\%)&#39;, size=15)</span>
<span class="sd">        cbar2.ax.tick_params(labelsize=15)</span>
<span class="sd">        </span>
<span class="sd">        plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipCheck</span><span class="p">:</span>
        <span class="n">samplingZone</span> <span class="o">=</span> <span class="n">_checkParams</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">samplingZone</span><span class="p">,</span> <span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Rb</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one of the following parameters was provided as a negative number, which is not correct: nx, ny, Rb, arcsecToGrid.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">PA</span><span class="o">&lt;-</span><span class="mi">90</span> <span class="ow">or</span> <span class="n">PA</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;PA should be given in the range -90° &lt;= PA &lt;= 90°, counting angles anti clock-wise (0° means major axis is vetically aligned). Cheers !&#39;</span><span class="p">)</span>
    
    <span class="c1"># Generating bulge model</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">Sersic2D</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">Rb</span><span class="p">],</span>
                           <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">listIe</span><span class="o">=</span><span class="p">[</span><span class="n">Ib</span><span class="p">],</span> <span class="n">listMag</span><span class="o">=</span><span class="p">[</span><span class="n">mag</span><span class="p">],</span> <span class="n">listOffset</span><span class="o">=</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span>
                           <span class="n">listInclination</span><span class="o">=</span><span class="p">[</span><span class="n">inclination</span><span class="p">],</span> <span class="n">listPA</span><span class="o">=</span><span class="p">[</span><span class="n">PA</span><span class="p">],</span>
                           <span class="n">fineSampling</span><span class="o">=</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="n">samplingZone</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skipCheck</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># PSF convolution</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">noPSF</span><span class="p">:</span>
        
        <span class="c1"># If we perform fine sampling only in the central part, Sersic2D function rebins the data at the end of the function,</span>
        <span class="c1"># So the arcsec to pixel conversion factor does not need to be updated since we do not have a finer pixel scale in our model</span>
        <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;centre&#39;</span><span class="p">:</span>
            <span class="n">fineSampling</span> <span class="o">=</span> <span class="mi">1</span>
    
        <span class="n">model</span> <span class="o">=</span> <span class="n">PSFconvolution2D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">PSF</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="o">=</span><span class="n">arcsecToGrid</span><span class="o">/</span><span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span></div>


<div class="viewcode-block" id="Sersic2D"><a class="viewcode-back" href="../../galaxy/models.html#galaxy.models.Sersic2D">[docs]</a><span class="k">def</span> <span class="nf">Sersic2D</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listIe</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listMag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listOffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listInclination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">listPA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">fineSampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">samplingZone</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;where&#39;</span><span class="p">:</span><span class="s1">&#39;centre&#39;</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">},</span> 
            <span class="n">skipCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">    </span>
<span class="sd">    Generate a (sky projected) 2D model (image) of a sum of Sersic profiles. Neither PSF smoothing, nor projections onto the sky whatsoever are applied here.</span>
<span class="sd">    </span>
<span class="sd">    .. rubric:: **How to use**</span>
<span class="sd">    </span>
<span class="sd">    Apart from the mandatory inputs, it is necessary to provide</span>

<span class="sd">    * an intensity at Re for each profile</span>
<span class="sd">    * a total magnitude value for each profile and a corresponding magnitude offset per profile (to convert from magnitudes to intensities)</span>
<span class="sd">   </span>
<span class="sd">    .. rubric: **Infos about sampling** </span>
<span class="sd">  </span>
<span class="sd">    **fineSampling** parameter can be used to rebin the data. The shape of the final image will depend on the samplingZone used</span>
<span class="sd">        </span>
<span class="sd">    * if the sampling is performed everywhere (&#39;where&#39; keyword in **samplingZone** equal to &#39;all&#39;), the final image will have dimensions (**nx*fineSampling**, **ny*fineSampling**)</span>
<span class="sd">    * if the sampling is performed around the centre (&#39;where&#39; equal to &#39;centre&#39;), the central part is over-sampled, but needs to be binned in the end so that pixels have the same size in the central part and around. Thus, the final image will have the dimension (**nx**, **ny**).        </span>
<span class="sd">       </span>
<span class="sd">    :param listn: list of Sersic index for each profile</span>
<span class="sd">    :type listn: list[int] or list[float]</span>
<span class="sd">    :param list[float] listRe: list of half-light radii for each profile</span>
<span class="sd">    :param int nx: size of the model for the x-axis</span>
<span class="sd">    :param int ny: size of the model for the y-axis</span>
<span class="sd">    </span>
<span class="sd">    :param bool combine: (**Optional**) whether to combine (sum) all the components and return a single intensity map, or to return each component separately in lists</span>
<span class="sd">    :param list[float] listIe: (**Optional**) list of intensities at re for each profile</span>
<span class="sd">    :param listInclination: (**Optional**) list of inclination of each Sersic component on the sky in degrees</span>
<span class="sd">    :type listInclination: list[int] or list[float]</span>
<span class="sd">    :type list[float] listMag: (**Optional**) list of total integrated magnitudes for each profile</span>
<span class="sd">    :type list[float] listOffset: (**Optional**) list of magnitude offsets used in the magnitude system for each profile</span>
<span class="sd">    :param listPA: (**Optional**) list of position angle of each Sersic component on the sky in degrees. Generally, these values are given between -90° and +90°.</span>
<span class="sd">    :type listPA: list[int] or list[float]</span>
<span class="sd">    :param int(&gt;0) fineSampling: (**Optional**) fine sampling for the pixel grid used to make high resolution models. For instance, a value of 2 means that a pixel will be split into two subpixels.</span>
<span class="sd">    :param dict samplingZone: (**Optional**) where to perform the sampling. Default is everywhere. Dictionnaries should have the following keys:</span>
<span class="sd">       </span>
<span class="sd">        * &#39;where&#39; (type str) -&gt; either &#39;all&#39; to perform everywhere or &#39;centre&#39; to perform around the centre</span>
<span class="sd">        * &#39;dx&#39;    (type int) -&gt; x-axis maximum distance from the centre coordinate. An sub-array with x-axis values within [xpos-dx, xpos+dx] will be selected. If the sampling is performed everywhere, &#39;dx&#39; does not need to be provided.</span>
<span class="sd">        * &#39;dy&#39;    (type int) -&gt; y-axis maximum distance from the centre coordinate. An sub-array with y-axis values within [ypos-dy, ypos+dy] will be selected. If the sampling is performed everywhere, &#39;dy&#39; does not need to be provided.</span>
<span class="sd">          </span>
<span class="sd">    :param bool skipCheck: (**Optional**) whether to skip the checking part or not</span>
<span class="sd">    :param bool verbose: (**Optional**) whether to print info on stdout or not</span>
<span class="sd">    :param x0: (**Optional**) x-axis centre position. Default is None so that **nx**//2 will be used.</span>
<span class="sd">    :type x0: int or float</span>
<span class="sd">    :param y0: (**Optional**) y-axis centre position. Default is None so that **ny**//2 will be used.</span>
<span class="sd">    :type y0: int or float</span>
<span class="sd">        </span>
<span class="sd">    :returns: </span>
<span class="sd">        </span>
<span class="sd">        * X, Y grids and the intensity map if **combine** is True</span>
<span class="sd">        * X, Y grids and a listof intensity maps for each component if **combine** is False</span>
<span class="sd">        </span>
<span class="sd">    :raises TypeError: </span>
<span class="sd">        </span>
<span class="sd">        * if &#39;dx&#39; and &#39;dy&#39; keys are not in **samplingZone**</span>
<span class="sd">        * if **fineSampling**, **nx** and **ny** are neither int, nor np.integer</span>
<span class="sd">        </span>
<span class="sd">    :raises ValueError:</span>
<span class="sd">        </span>
<span class="sd">        * if &#39;where&#39; key value in **samplingZone** is neither &#39;all&#39;, nor &#39;centre&#39;</span>
<span class="sd">        * if nx, ny or arcsecToGrid are &lt; 0</span>
<span class="sd">        * if at least one n or one Re is &lt; 0</span>
<span class="sd">        * if **fineSampling** &lt; 1</span>
<span class="sd">        * if at least one PA is not in the range [-90, 90] deg</span>
<span class="sd">        * if Ie and mag and offset are None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">computeSersic</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">):</span>
        
        <span class="c1"># We need not specify a centre coordinate offset, because the X and Y grids are automatically centred on the real centre.</span>
        <span class="c1"># If we combine models, we add them, if we do not combine them, we place them into a list</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">ie</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">pa</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nbModels</span><span class="p">),</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">):</span>
            
            <span class="c1"># We add 90 to PA because we want a PA=0° galaxy to be aligned with the vertical axis</span>
            <span class="n">ell</span>                <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">inc</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
            <span class="n">pa</span>                <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
            <span class="n">theModel</span>           <span class="o">=</span> <span class="n">astmod</span><span class="o">.</span><span class="n">Sersic2D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">ie</span><span class="p">,</span> <span class="n">r_eff</span><span class="o">=</span><span class="n">re</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">x_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ellip</span><span class="o">=</span><span class="n">ell</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">pa</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
                    <span class="n">intensity</span>  <span class="o">=</span> <span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intensity</span>  <span class="o">=</span> <span class="p">[</span><span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
                    <span class="n">intensity</span> <span class="o">+=</span> <span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intensity</span> <span class="o">+=</span> <span class="p">[</span><span class="n">theModel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ell</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">intensity</span>
    
    <span class="c1">##############################################</span>
    <span class="c1">#          Checking input parameters         #</span>
    <span class="c1">############################################## </span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipCheck</span><span class="p">:</span>
        <span class="n">samplingZone</span> <span class="o">=</span> <span class="n">_checkParams</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">samplingZone</span><span class="p">,</span> <span class="n">fineSampling</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">arcsecToGrid</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one of the following parameters was provided as a negative number, which is not correct: nx, ny, arcsecToGrid.&#39;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="p">[</span><span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one element in listn or listRe is a negative number, which is not correct.&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">pa</span><span class="o">&lt;-</span><span class="mi">90</span> <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="n">listPA</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="n">pa</span><span class="o">&gt;</span><span class="mi">90</span> <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="n">listPA</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;PA should be given in the range -90° &lt;= PA &lt;= +90°, counting angles anti clock-wise. Cheers !&#39;</span><span class="p">)</span>
        

    <span class="k">if</span> <span class="n">listIe</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">listIe</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">listMag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">listOffset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">listIe</span>         <span class="o">=</span> <span class="n">intensity_at_re</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listn</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listMag</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listRe</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listOffset</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;listIe is None, but listMag or listOffset is also None. If no listIe is given, please provide a value for the total magnitude and magnitude offset in order to compute the intensities. Cheers !&quot;</span><span class="p">)</span>

    <span class="n">nbModels</span>               <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">listn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">listInclination</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">listInclination</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nbModels</span>
    <span class="k">if</span> <span class="n">listPA</span>          <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">listPA</span>             <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nbModels</span>

    <span class="c1">##################################</span>
    <span class="c1">#         Compute models         #</span>
    <span class="c1">##################################</span>

    <span class="c1"># Define image centre</span>
    <span class="n">midX</span>                   <span class="o">=</span> <span class="n">nx</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">midY</span>                   <span class="o">=</span> <span class="n">ny</span><span class="o">//</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x0</span>                 <span class="o">=</span> <span class="n">midX</span>
    <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y0</span>                 <span class="o">=</span> <span class="n">midY</span>
        
    <span class="c1"># Pixel width is not 1 if we use fineSampling</span>
    <span class="n">pixWidth</span>               <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fineSampling</span>
    <span class="n">pixHeight</span>              <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fineSampling</span>
    
    <span class="c1"># We centre the coordinate X and Y grids to the given centre coordinates</span>
    <span class="c1"># The centre is recentred inside an &#39;original&#39; pixel because of fine sampling (to not break any symmetry when rebinning)</span>
    <span class="k">if</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">newX0</span>              <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pixWidth</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">newY0</span>              <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pixHeight</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">listX</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">pixWidth</span><span class="p">)</span>  <span class="o">-</span> <span class="n">newX0</span>
        <span class="n">listY</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixHeight</span><span class="p">)</span> <span class="o">-</span> <span class="n">newY0</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">listX</span><span class="p">,</span> <span class="n">listY</span><span class="p">)</span>
        <span class="n">intensity</span>          <span class="o">=</span> <span class="n">computeSersic</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">fineSampling</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Rebinning intensity map in the central part</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        intensity   = intensity.reshape(int(intensity.shape[0] / fineSampling), fineSampling, int(intensity.shape[1] / fineSampling), fineSampling)</span>
<span class="sd">        intensity   = intensity.mean(1).mean(2)</span>
<span class="sd">        </span>
<span class="sd">        listX              = np.arange(0, nx, 1) - x0</span>
<span class="sd">        listY              = np.arange(0, ny, 1) - y0</span>
<span class="sd">        X, Y               = np.meshgrid(listX, listY)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="c1"># We generate grids with pixel size of 1x1 (and we centre it on the galaxy centre)</span>
        <span class="n">listX</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x0</span>
        <span class="n">listY</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">y0</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">listX</span><span class="p">,</span> <span class="n">listY</span><span class="p">)</span>
        <span class="n">intensity</span>          <span class="o">=</span> <span class="n">computeSersic</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">)</span>
        
        <span class="c1"># We generate a subarray around the centre in the given box, using the given over-sampling factor</span>
        <span class="n">maxX</span>               <span class="o">=</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fineSampling</span><span class="p">)</span> <span class="c1"># Weird but that&#39;s what comes out of a few diagrams</span>
        <span class="n">maxY</span>               <span class="o">=</span> <span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fineSampling</span><span class="p">)</span>
        <span class="n">listXcenPart</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxX</span><span class="p">,</span> <span class="n">maxX</span><span class="o">+</span><span class="n">pixWidth</span><span class="p">,</span> <span class="n">pixWidth</span><span class="p">)</span>
        <span class="n">listYcenPart</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxY</span><span class="p">,</span> <span class="n">maxY</span><span class="o">+</span><span class="n">pixHeight</span><span class="p">,</span> <span class="n">pixHeight</span><span class="p">)</span>
        
        <span class="n">XcenPart</span><span class="p">,</span> <span class="n">YcenPart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">listXcenPart</span><span class="p">,</span> <span class="n">listYcenPart</span><span class="p">)</span>
        <span class="n">intensityCenPart</span>   <span class="o">=</span> <span class="n">computeSersic</span><span class="p">(</span><span class="n">XcenPart</span><span class="p">,</span> <span class="n">YcenPart</span><span class="p">,</span> <span class="n">nbModels</span><span class="p">,</span> <span class="n">listn</span><span class="p">,</span> <span class="n">listRe</span><span class="p">,</span> <span class="n">listIe</span><span class="p">,</span> <span class="n">listInclination</span><span class="p">,</span> <span class="n">listPA</span><span class="p">)</span>

        <span class="c1"># Rebinning intensity map in the central part</span>
        <span class="n">intensityCenPart</span>   <span class="o">=</span> <span class="n">intensityCenPart</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">intensityCenPart</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">fineSampling</span><span class="p">),</span> <span class="n">fineSampling</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">intensityCenPart</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">fineSampling</span><span class="p">),</span> <span class="n">fineSampling</span><span class="p">)</span>
        <span class="n">intensityCenPart</span>   <span class="o">=</span> <span class="n">intensityCenPart</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">fineSampling</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Combining back the central part into the original array</span>
        <span class="n">intensity</span><span class="p">[</span><span class="n">y0</span><span class="o">-</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]:</span><span class="n">y0</span><span class="o">+</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]:</span><span class="n">x0</span><span class="o">+</span><span class="n">samplingZone</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensityCenPart</span>
        
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">intensity</span></div>





</pre></div>

              </div>
              
        
        <div class='prev-next-bottom'>
            

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Wilfried Mercier<br/>
        
            &copy; Copyright 2021, Wilfried Mercier.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>